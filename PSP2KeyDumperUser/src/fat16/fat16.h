/*
 * Easy FAT16 Library
 * Copyright (C) 2021, Princess of Sleeping
 */

#ifndef _FAT16_BASE_H_
#define _FAT16_BASE_H_

typedef struct BPB_t {

	/*
	 * ブートストラップ
	 * プログラムへのジャンプ命令(x86命令)。このフィールドには次の2つのフォーマットがあり、前者が一般的。
	 * 0xEB, 0x??, 0x90 (ショート ジャンプ+NOP)
	 * 0xE9, 0x??, 0x?? (ニア ジャンプ)
	 * ??はジャンプ先により異なる任意の値。これらから外れたフォーマットの場合、そのボリュームはWindowsで認識されない。
	 */
	char     BS_JmpBoot[0x3];	// 0xEB, 0xFE, 0x90

	/*
	 * "MSWIN4.1"が推奨される。
	 * ほかに"MSDOS5.0"などがよく使われる。
	 * このフィールドに関しては、多くの誤解がある。
	 * これは単なる名前である。
	 * マイクロソフトのOSはこのフィールドに何ら注意を払わないが、いくつかのFATドライバは何らかの参照を行う。
	 * この文字列が推奨されるのは、それが互換性問題を最小にする設定であることが理由である。
	 * 何か違う値を設定しても良いが、いくつかのFATドライバはそのボリュームを認識できないかも知れない。
	 * このフィールドは、たいていはそのボリュームを作成したシステムを示している。
	 */
	char     BS_OEMName[0x8];	// "SCEI    "

	/*
	 * バイト単位のセクタ サイズ。
	 * 有効な値は、512, 1024, 2048または4096である。
	 * マイクロソフトのOSはこれらのセクタ サイズを適切にサポートする。
	 * しかし、サポートするセクタ サイズを512に限定していても、
	 * このフィールドが512であることをチェックしないFATドライバが多く存在するため、
	 * 最大限の互換性が要求されるときは512を使うべきである。
	 * ただし、それは単に互換性に関することであるというのを誤解しないこと。
	 * この値は、そのボリュームを格納するストレージのセクタ サイズと同じでなければならない。
	 */
	uint16_t BPB_BytsPerSec;	// off:0xB, 0x200

	/*
	 * アロケーション ユニット(割り当て単位)当たりのセクタ数。
	 * FATファイルシステムでは、アロケーション ユニットのことをクラスタと呼んでいる。
	 * これは1個以上の連続したセクタのブロックのことで、データ領域はこれを単位に管理される。
	 * クラスタ当たりのセクタ数は、2の累乗でなければならない。
	 * したがって、有効な値は、1, 2, 4, ..., 128ということになるが、
	 * クラスタ サイズ(BPB_BytsPerSec * BPB_SecPerClus)が32Kバイトを越す値は使用すべきではない。
	 * 最近のシステム(例えばWindows98やNT系Windows)では 64K, 128K, 256Kバイトといったクラスタ サイズも扱えるが、
	 * そのようなボリュームは古いシステムやディスク ユーティリティに正しく認識されないかもしれない。
	 */
	uint8_t  BPB_SecPerClus;	// off:0xD, 0x8

	/*
	 * 予約領域のセクタ数。
	 * このフィールドは0であってはならない(少なくともこのBPBを含むブートセクタそれ自身が存在する)。
	 * 互換性問題を避けるため、FAT12/16ボリュームでは1にするべきである。
	 * なぜなら、FAT12/16の予約領域は1セクタであると決め打ちし、このフィールドを無視するツールやFATドライバが存在するからである。
	 * FAT32ボリュームでは代表的には32である。
	 * マイクロソフトのOSは1以上の値を適切にサポートする。
	 */
	uint16_t BPB_RsvdSecCnt;	// off:0xE, 0x2

	/*
	 * FATの数。
	 * このフィールドの値は常に2に設定すべきである。
	 * 1以上の何らかの値もまた有効ではあるが、
	 * 互換性問題を避けるため2以外の値は使用しないことが強く推奨される。
	 * マイクロソフトのFATドライバは2以外の値も適切にサポートするが、
	 * いくつかのツールやFATドライバにはこのフィールドを無視してFAT数2で動作するものがある。
	 *
	 * このフィールドの標準値が2であるのはFATに冗長性を持たせるためで、
	 * もしFAT中の一部のセクタが破損しても多重化されたもう一つのFATがあるので、
	 * ファイルが失われる危険が少なくなる。
	 * メモリ カードのような非ディスク ストレージではそのような冗長性は無用な機能なので1でも良いが、
	 * そのようなボリュームは互換性が低下するかも知れない。
	 */
	uint8_t  BPB_NumFATs;		// off:0x10, 0x2

	/*
	 * FAT12/16ボリュームでは、ルート ディレクトリに含まれるディレクトリ エントリの数を示す。
	 * このフィールドには、ディレクトリ テーブルのサイズが2セクタ境界にアライメントする値、
	 * つまり、BPB_RootEntCnt * 32がBPB_BytsPerSecの偶数倍になる値を設定すべきである(32というのはディレクトリ エントリ1個のサイズ)。
	 * 最大の互換性のためには、FAT16では512に設定すべきである。
	 * FAT32ボリュームではこのフィールドは使われず、常に0でなければならない。
	 */
	uint16_t BPB_RootEntCnt;	// off:0x11, 0x200

	/*
	 * ボリュームの総セクタ数(古い16ビット フィールド)。
	 * この値は、ボリュームの4つの領域全てを含んだセクタ数である。
	 * FAT12/16でボリュームのセクタ数が0x10000以上になるときは、このフィールドには無効値(0)が設定され、真の値がBPB_TotSec32に設定される。
	 * FAT32ボリュームでは、このフィールドは必ず無効値でなければならない。
	 */
	uint16_t BPB_TotSec16;		// off:0x13, 0x0000

	/*
	 * 区画分けされた固定ディスク ドライブでは0xF8が標準値である。
	 * 区画分けされないリムーバブル メディアでは0xF0がしばしば使われる。
	 * このフィールドに有効な値は、0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFEおよび0xFFで、
	 * ほかに重要な点はこれと同じ値をFAT[0]の下位8ビットに置かなければならないということだけである。
	 * これは、MS-DOS 1.xでメディア タイプの設定に遡り、既に使われていない。
	 */
	uint8_t  BPB_Media;		// off:0x15, 0xF8

	/*
	 * 1個のFATが占めるセクタ数。
	 * このフィールドはFAT12/FAT16ボリュームでのみ使われる。
	 * FAT32ボリュームでは必ず無効値(0)でなければならず、代わりにBPB_FATSz32が使われる。
	 * FAT領域のサイズは、この値 * BPB_NumFATsセクタとなる。
	 */
	uint16_t BPB_FATSz16;		// off:0x16, 0x103, 0x13

	/*
	 * トラック当たりのセクタ数。
	 * このフィールドは、ジオメトリを持つストレージにのみ関係し、IBM PCのディスクBIOSで使用される。
	 * それ以外では意味がない。
	 */
	uint16_t BPB_SecPerTrk;		// off:0x18, 0x3F

	/*
	 * ヘッド数。
	 * このフィールドは、ジオメトリを持つストレージにのみ関係し、IBM PCのディスクBIOSで使用される。
	 * それ以外では意味がない。
	 */
	uint16_t BPB_NumHeads;		// off:0x1A, 0xFF

	/*
	 * ストレージ上でこのボリュームの手前に存在する隠れた物理セクタの数。
	 * 一般的にIBM PCのディスクBIOSでアクセスされるストレージに関するものであり、どのような値が入るかはシステム依存。
	 * ボリュームがストレージの先頭から始まる場合(つまりフロッピー ディスクなど区画分けされていないもの)では常に0であるべきである。
	 */
	uint32_t BPB_HiddSec;		// off:0x1C

	/*
	 * ボリュームの総セクタ数(新しい32ビット フィールド)。
	 * この値は、ボリュームの4つの領域全てを含んだセクタ数である。
	 * FAT12/16ボリュームで総セクタ数が0x10000未満のとき、
	 * このフィールドは無効値(0)でなければならなず、真の値はBPB_TotSec16に設定される。
	 * FAT32ボリュームでは常に有効値が入る。
	 */
	uint32_t BPB_TotSec32;		// off:0x20
} __attribute__((packed)) BPB_t;

typedef struct FAT16_BASE_t {
	/*
	 * IBM PCのディスクBIOSで使われるドライブ番号。
	 * このフィールドは、MS-DOSのブートストラップで使われ、フロッピーディスクでは0x00、固定ディスクでは0x80である。
	 * 実際にはOS依存。
	 */
	uint8_t  BS_DrvNum;		// off:0x24

	/*
	 * 予約(WindowsNTで使用)。
	 * フォーマットするときは常に0を設定すべきである。
	 */
	uint8_t  BS_Reserved1;		// off:0x25

	/*
	 * 拡張ブートシグネチャ (0x29)。
	 * これは、続く3つのフィールドが存在することを示す。
	 */
	uint8_t  BS_BootSig;		// off:0x26

	/*
	 * ボリュームシリアル番号。
	 * このフィールドとBS_VolLabでリムーバブル ストレージにおけるボリュームの追跡をサポートする。
	 * これらの値はFATドライバが不正なメディア交換を検出するのを助ける。
	 * このIDは大抵は現在時刻から生成される。
	 */
	uint32_t BS_VolID;		// off:0x27

	/*
	 * ボリュームラベル。
	 * このフィールドは、ルート ディレクトリに記録される11バイトのボリューム ラベルに一致する。
	 * FATドライバは、ルート ディレクトリのボリューム ラベルを更新したら、この値にも反映させるべきである。
	 * ボリューム ラベルが無い場合は、"NO NAME "を設定する。
	 */
	char     BS_VolLab[11];		// off:0x2B

	/*
	 * "FAT12   ", "FAT16   ", "FAT32   "または"FAT     "のうちいずれかの文字列。
	 * 多くの人はこの文字列がFATタイプの決定に何らかの関与をしていると思っているが、それは明確に間違いである。
	 * このフィールドの名前から、これはBPBの一部ではないことが分かると思う。
	 * この文字列は不正確だったり設定されていなかったりすることがしばしばあるので、
	 * マイクロソフトのFATドライバはFATタイプの決定にこのフィールドを使わない。
	 * しかし、一部のFATドライバはこの文字列を使用しているので、
	 * 互換性問題を避けるためこの文字列はそのボリュームのFATタイプに基づいて設定されるべきである。
	 */
	char     BS_FilSysType[8];	// off:0x36

	/*
	 * ブートストラップ プログラム。
	 * システム依存フィールドで、未使用時はゼロで埋める。
	 */
	char     BS_BootCode[448];	// off:62

	/*
	 * 0xAA55。有効なブート セクタであることを示すブート シグネチャ。
	 */
	uint16_t BS_BootSign;
} __attribute__((packed)) FAT16_BASE_t;

typedef struct FAT16_t {
	BPB_t        bpb;
	FAT16_BASE_t fat16_base;
} __attribute__((packed)) FAT16_t;

typedef struct EntryFileName_t {
	/*
	 * このエントリがLFNエントリ(1個のLFNを構成するエントリ群)のどの部分かを示すシーケンス番号(1～20)。
	 * 1がLFNの先頭部を意味する。
	 * LAST_LONG_ENTRYフラグ(0x40)が立っているときは、シーケンスの最後尾の部分であることを示す。
	 */
	uint8_t  LDIR_Ord;

	/*
	 * 名前。1文字目～5文字目。
	 */
	uint16_t LDIR_Name1[5];

	/* 
	 * LFNアトリビュート。
	 * このエントリがLFNエントリの一部であることを示すため、ATTR_LONG_NAMEでなければならない。
	 */
	uint8_t  LDIR_Attr;

	/*
	 * LFNのタイプ。常に0でなければならず、0以外は予約。
	 */
	uint8_t  LDIR_Type;

	/*
	 * このLFNエントリと結びつけられているSFNエントリのチェックサム。
	 */
	uint8_t  LDIR_Chksum;

	/*
	 * 名前。6文字目～11文字目。
	 */
	uint16_t LDIR_Name2[6];

	/*
	 * 古いディスクユーティリティによる危険の可能性を避けるため、0がセットされる。
	 */
	uint16_t LDIR_FstClusLO;

	/*
	 * 名前。12文字目～13文字目。
	 */
	uint16_t LDIR_Name3[2];
} __attribute__((packed)) EntryFileName_t;

typedef struct EntryInfo_t {

	/*
	 * 短いファイル名の本体名と拡張子。
	 */
	char DIR_Name[11];

	/*
	 * ファイル アトリビュート。次のフラグのコンビネーションで表現される。上位2ビットは未使用で0でなければならない。
	 * 0x01: ATTR_READ_ONLY (書き込み禁止)
	 * 0x02: ATTR_HIDDEN (隠し)
	 * 0x04: ATTR_SYSTEM (システム)
	 * 0x08: ATTR_VOLUME_ID (ボリューム ラベル)
	 * 0x10: ATTR_DIRECTORY (ディレクトリ)
	 * 0x20: ATTR_ARCHIVE (アーカイブ)
	 * 0x0F: ATTR_LONG_FILE_NAME (LFNエントリ)
	 */
	char DIR_Attr;

	/*
	 * 短いファイル名の小文字情報を記録するフラグ(オプション)。
	 * 0x08: 本体名がすべて小文字。
	 * 0x10: 拡張子がすべて小文字。
	 */
	char DIR_NTRes;

	/*
	 * DIR_CrtTimeのサブセコンド情報。
	 * DIR_CrtTimeの分解能は2秒であるが、それをさらに200分割した値(0～199)が入る。
	 * サポートしない場合は、作成時に0を設定し、以降変更しない。
	 */
	char DIR_CrtTimeTenth;

	/*
	 * このファイルが作成された時刻(オプション)。
	 * サポートしない場合は、作成時に0を設定し、以降変更しない。
	 */
	uint16_t DIR_CrtTime;

	/*
	 * このファイルが作成された日付(オプション)。サポートしない場合は、作成時に0を設定し、以降変更しない。
	 */
	uint16_t DIR_CrtDate;

	/*
	 * このファイルを最後にオープンした日付(オプション)。時刻情報は無い。書き込みアクセスの場合はDIR_WrtDateと同じ値を設定すべきである。サポートしない場合は、作成時に0を設定し、以降変更しない。
	 */
	uint16_t DIR_LstAccDate;

	/*
	 * このファイルの先頭クラスタ番号の上位16ビット。FAT12/16では常に0。
	 */
	uint16_t DIR_FstClusHI;

	/*
	 * このファイルが最後に書き込まれた(書き込み後クローズされた)時刻。サポート必須。
	 */
	uint16_t DIR_WrtTime;

	/*
	 * このファイルが最後に書き込まれた日付。サポート必須。
	 */
	uint16_t DIR_WrtDate;

	/*
	 * このファイルの先頭クラスタ番号の下位16ビット。ファイル サイズが0のときは常に0。
	 */
	uint16_t DIR_FstClusLO;

	/*
	 * このファイルのバイト単位のサイズ。ディレクトリの場合は常に0。
	 */
	uint32_t DIR_FileSize;
} __attribute__((packed)) EntryInfo_t;

#endif	/* _FAT16_BASE_H_ */
